package main

import (
	"fmt"
	"io/ioutil"
	"log"

	"gopkg.in/yaml.v2"
)

type subset map[string]interface{}

// Create a copy of a map and all its nested maps.
func copyMap(target subset) subset {
	targetCopy := subset{}
	for key, value := range target {
                switch value := value.(type) {
                        case string:
		                targetCopy[key] = value
                        case subset:
                                targetCopy[key] = copyMap(value)
                }
	}
	return targetCopy
}

// Append entire map to the end of target map.
func appendWholeItemToMap(targetMap interface{}, appendingItemKey string, appendingItemValue interface{}) {
        pointer := targetMap
        for len(pointer) != 0 {
                for key, _ := range pointer {
                        pointer = pointer[key].(subset)
                }
        }
        pointer[appendingItemKey] = appendingItemValue


func appendNextItemToMap(targetMap interface{}, appendingItemKey interface{}) {
        pointer := targetMap
        for len(pointer.(subset)) != 0 {
                for _, value := range pointer.(subset) {
                        //pointer = value.(subset)
                        pointer = value
                }
        }
        //pointer[appendingItemKey] = subset{}
        //switch appendingType := appendingItemKey.(type) {
        //        case string:
        //                pointer[appendingItemKey] = appendingItemKey
        //        case interface{}:
        //                pointer[appendingItemKey] = subset{}
        //}
        //pointer.(subset)["test"] = "test2"
        switch appendingType := appendingItemKey.(type) {
                case interface{}:
                        pointer.(subset)[appendingItemKey] = subset{}
                case string:
                        //fmt.Println("string", appendingType)
                        pointer.(subset)[appendingItemKey] = appendingType
                case nil:
                        pointer.(subset)[appendingItemKey] = nil
        }
}

// Create a cache for each path and return path to target when target is encountered.
func searchMap(child interface{}, cache subset, target string) {
        for key, _ := range child.(subset) {
		nextCache := subset{}
		for cacheKey, cacheValue := range cache {
			nextCache[cacheKey] = cacheValue
		}
                appendNextItemToMap(nextCache, key)
                fmt.Println(nextCache)

                switch nextChild := child.(subset)[key].(type) {
                case string:
			//fmt.Println("string", cache)
                case interface{}:
			//fmt.Println("interface", cache)
                        searchMap(nextChild, nextCache, target)
                case nil:
			//fmt.Println("nil", cache)
                }
        }
}

//func searchMap(child interface{}, cache subset, target string) {
//        for key, _ := range child.(subset) {
//		nextCache := copyMap(cache)
//		appendNextItemToMap(nextCache, key)
//                nextChild := child.(subset)[key].(subset)
//                searchMap2(nextChild, nextCache, target)
//                //fmt.Println("key", key)
//		//fmt.Println(child.(subset)[key])
//                //fmt.Println("nextCache", nextCache)
//		//switch nextChild := child.(subset)[key].(type) {
//		//case string:
//                //        fmt.Println("string")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//	appendNextItemToMap(nextCache, nextChild)
//		//case interface{}:
//                //        fmt.Println("interface")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//        searchMap(nextChild, nextCache, target)
//		//case nil:
//                //        fmt.Println("nil")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//	appendNextItemToMap(nextCache, nextChild)
//		//}
//        }
//}
//
//func searchMap2(child interface{}, cache subset, target string) {
//        for key, _ := range child.(subset) {
//                //fmt.Println(key)
//                //fmt.Println(cache)
//		nextCache := copyMap(cache)
//		appendNextItemToMap(nextCache, key)
//                //fmt.Println(nextCache)
//                //fmt.Println("nextCache2", nextCache)
//                //fmt.Println("key", key)
//		//fmt.Println(child.(subset)[key])
//                //fmt.Println("nextCache", nextCache)
//		//switch nextChild := child.(subset)[key].(type) {
//		//case string:
//                //        fmt.Println("string")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//	appendNextItemToMap(nextCache, nextChild)
//		//case interface{}:
//                //        fmt.Println("interface")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//        searchMap(nextChild, nextCache, target)
//		//case nil:
//                //        fmt.Println("nil")
//                //        fmt.Println("nextCache", nextCache)
//                //        fmt.Println("nextChild", nextChild)
//		//	appendNextItemToMap(nextCache, nextChild)
//		//}
//        }
//
//}

func main() {

	content, err := ioutil.ReadFile("test.yaml")
	if err != nil {
		log.Fatal(err)
	}

	m := subset{}
	err = yaml.Unmarshal(content, m)
	if err != nil {
		log.Fatalf("cannot unmarshal data: %v", err)
	}
	testMap := subset{}
        testMap2 := subset{}
        testMap3 := subset{}
        testMap4 := subset{}
        testMap5 := subset{}
        testMap6 := subset{}
        testMap5["key5"] = testMap6
        testMap4["key4"] = testMap5

        testMap2["key2"] = testMap3
        testMap["key"] = testMap2
        testMap2["keycopy"] = "testMapCopy"
        //fmt.Println(testMap)

	cache := subset{}
        //searchMap(m, cache, "us-west-2")
        copyCacheTest(m, cache, "us-west-2")
        //copyCacheTest(testMap, cache, "test")
	//fmt.Println(m)

}

func copyCacheTest(child interface{}, cache subset, target string) {
        for key, _ := range child.(subset) {
                nextCache := copyMap(cache)
                appendNextItemToMap(nextCache, key)
                nextChild := child.(subset)[key].(subset)
                fmt.Println("firstnextcache", nextCache)
                copyCacheTest2(nextChild, nextCache, target)
        }
}

func copyCacheTest2(child interface{}, cache subset, target string) {
        fmt.Println("secondnextcache", cache)
        for key, _ := range child.(subset) {
                fmt.Println("cache1", cache)
                nextCache := copyMap(cache)
                fmt.Println("cache2", cache)
                appendNextItemToMap(nextCache, key)
                fmt.Println("cache3", cache)
        }
}
